# WorkFlow para o fluxo de trabalho CI/CD de um Projeto React. Começa automaticamente e 
# executa uma série de etapas, que incluem clonar o repositório, instalar as dependências,
# testar o código, e implantar no Google Cloud. 
#
# Nesse exemplo, o workflow é acionado toda vez que um push é feito para a branch "main", 
# e ele consiste em um único job chamado "testes". Esse job roda em uma máquina virtual com 
# sistema operacional Ubuntu e é composto por steps: checkout do repositório, instalação 
# das dependências, execução dos testes, set up node.js, analise com sonarclound
#
# Para que a equipe possa fazer mudanças no projeto em Front/React, eles precisam ter acesso de 
# escrita ao repositório. Para conceder acesso, o proprietário ou administrador deve acessar as
# configurações do repositório no GitHub, selecionar a aba "Manage access" e adicionar os usuários 
# ou equipes que deseja conceder acesso.
#
# Para criar um pull request, o desenvolvedor precisa criar uma branch com as mudanças que deseja
# incorporar e, em seguida, solicitar a integração dessa branch à branch de destino por meio do 
# botão "Create Pull Request" no GitHub. Já para fazer um push, o desenvolvedor pode utilizar o 
# comando git push em sua máquina local para enviar as mudanças para o repositório remoto no GitHub.
# Uma vez que o push é feito, o workflow configurado será acionado automaticamente
#
# Os desenvolvedores podem acompanhar o progresso do workflow na página "Actions" do repositório,
# e receber notificações sobre erros ou falhas nas tarefas executadas. Com isso, eles podem corrigir
# as alterações e tentar novamente, garantindo que o código esteja sempre em um estado funcional e 
# seguro.
#
# Detalhe: o workflow se encontra dentro da pasta raiz do projeto, não é uma boa prática criar workflow´s
# fora da pasta raiz, visto que deverá especificar a "ref:" e o "path:", e mesmo assim poderá ter conflitos
# e erros, além de dificultar o gerenciamento do projeto entre os Devs.

name: CI/CD Projeto React

on:
  push:
    branches: 
    - main
  pull_request:
    branches:
    - main
    
jobs:
  test:
  
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [14.x]
    
    steps:
      - name: checkout code repository
        uses: actions/checkout@v3
        
      - name: Set up Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
          
      - name: Install dependencies
        run: npm install
        
      - name: Run tests and Coverage
        run: npm test -- --coverage
        
      - name: Analyze with SonarClound
        uses: sonarsource/sonarcloud-github-action@master
        
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONARCLOUND_TOKEN }}
        
  deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Execute deployment script
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            chmod +x /root/pipeline-react-app.sh
            /root/pipeline-react-app.sh
            
            
# O código acima é um exemplo de um fluxo de trabalho de CI/CD para uma aplicação React em que, quando 
# um desenvolvedor faz uma alteração no branch "main", o código é construído e 
# testado no Ubuntu-latest. Se os testes forem bem-sucedidos, o código é implantado no Google Cloud. 
# O uso do "actions/checkout@v3" garante que o código mais recente do branch "main" seja recuperado. 
# As etapas "Install dependencies" e "Run tests" são executadas para instalar as dependências necessárias 
# e executar os testes da aplicação. E finalmente, a etapa "Deploy to Google Cloud" usa a ação 
# "appleboy/ssh-action@master" para implantar o código no Google Cloud por meio do SSH.
#
# Foi definido uma matrix matriz de versõe do Node.js para ser usada durante a execução da ação.
# a ação é nomeada como "Set up Node.js" com a versão especificada através do valor ${{ matrix.node-version }}, 
# que é um valor dinâmico que será preenchido posteriormente pela matriz de versões definida mais abaixo no arquivo.
# a ação utiliza o pacote actions/setup-node@v3 para configurar o ambiente de execução da ação com a versão do Node.js 
# especificada na matriz. O parâmetro node-version é configurado com a versão do Node.js da matriz para que a ação possa 
# ser executada usando essa versão específica
#
# Os testes são geralmente definidos no arquivo "package.json" da sua aplicação React e é usado 
# para executar os testes pelo desenvolvedor. Um dos testes padrões muito utilizado é o 
# "jest", que é uma biblioteca popular para escrever testes em JavaScript. O passo "Run tests and Coverage"
# executa o comando de teste e cobertura de código no projeto. O comando npm test -- --coverage executa os 
# testes definidos no projeto e também gera um relatório de cobertura de código.
#
# O passo "Analyze with SonarCloud" utiliza a ação "sonarsource/sonarcloud-github-action@master" para analisar 
# o código-fonte do projeto e enviar os resultados para o SonarCloud. As variáveis de ambiente "GITHUB_TOKEN" e 
# "SONAR_TOKEN" são usadas para autenticação com o GitHub e o SonarCloud, respectivamente.
#
# "appleboy/ssh-action@master" é uma ação disponível no marketplace do GitHub que permite executar comandos 
# em um servidor remoto por meio do protocolo SSH. essa ação é usada para implantar a aplicação React no 
# Google Cloud. A ação se conecta ao servidor remoto usando as informações de conexão SSH fornecidas nas 
# variáveis de ambiente do fluxo de trabalho e executa um script que atualiza o código para a versão mais 
# recente, instala as dependências necessárias e executa os testes novamente no servidor remoto.
#
# http://35.226.197.229:3000/ (ativo por dente indeterminado), este será o link por onde pretende-se da 
# continuidade com esse estudo de caso. Foi criado uma .sh e .service na VM para este projeto.
#
# PENDENTE: desenvolver componentes, criar teste de unidade com JEST, para butão, condições de liite, etc..
# A ideia é poder ter a porcentagem do COVERAGE, visto que o projeto é o basico criado pelo REACT, logo, 
# é de responsabilidade do DEV criar funções para realizar testes unitários.
#
# PENDENTE: Discutir com os mentores os erros no DEPLOY. Os estudos demostram que deve-se criar um par de chaves SSH
# que sejam estáticas, seguindo as regras do ambiente de desenvolvimento do GOOGLE CLOUND.
